# -*- coding: utf-8 -*-
"""bakalauras 8.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1u68KscUgv25yC9C5g30sattEvNaGq9V2
"""

##Imortuojamos bibliotekos:

import keras
import tensorflow as tf
from tensorflow import keras
#Šioje bibliotekoje pateikiamas optimizatorius RMSprop:
from tensorflow.keras.optimizers import RMSprop
#Šioje bibliotekoje pateikiamos vaizdo pirminio apdorojimo ir duomenų papildymo funkcijos. 
#Į ją įtraukti įrankiai, skirti vaizdų duomenims įkelti, iš anksto apdoroti ir papildyti: 
from tensorflow.keras.preprocessing import image
from tensorflow.keras.preprocessing.image import ImageDataGenerator

import numpy as np 
import pandas as pd
import random
from PIL import Image
#Matplotlib yra Python skirta braižymo biblioteka vizualizacijoms kurti:
import matplotlib.pyplot as plt 
#cv2 yra Python modulis, skirtas OpenCV funkcijoms pasiekti:
import cv2 
#os modulis suteikia galimybę naudotis nuo operacinės sistemos priklausančiomis funkcijomis:
import os

## Importuojami duomenys 
from zipfile import ZipFile
filename = "training.zip"

with ZipFile ("training.zip",'r') as zip:
  zip.extractall()
  print('done')

## Importuojami duomenys 
from zipfile import ZipFile
filename = "testing.zip"

with ZipFile ("testing.zip",'r') as zip:
  zip.extractall()
  print('done')

# Patikriname ar kodas nuskaito nuotraukas su random funkcija
random_path = '/content/train/no_training'

# Gaunamas visų kataloge esančių failų pavadinimų sąrašąs:
file_names = os.listdir(random_path)

# Pasirenkama nuotrauka atsitiktiniu būdu:
random_file = random.choice(file_names)

# Pavaziduojama pasirinkta nuotrauka:
img = Image.open(os.path.join(random_path, random_file))
plt.imshow(img)
plt.axis('off')
plt.show()

#Antras patikrinimas naudojant pasirinktą nuotrauką:
img = image.load_img("/content/train/yes_training/Y8.jpg")
plt.imshow(img)

## Mokomųjų vaizdų konvertavimas į duomenų rinkinį
# Perskaitomas pasirinktas vaizdo failas ir gaunama išvestis yra 3 dimensijų matrica
cv2.imread("/content/train/yes_training/Y8.jpg")

# Tikriname pasirinkto failo matmenis
cv2.imread("/content/train/yes_training/Y8.jpg").shape

# Kiekvienas matricoje esantis elementas padalinamas tam, kad elementų reikšmė svyruotų nuo 0 iki 1.
train = ImageDataGenerator(rescale= 1/255)

# Iš pažymėtame kataloge esančių vaizdų sukurtas duomenų rinkinys modeliui mokyti
train_dataset = train.flow_from_directory('/content/train/',
                                          target_size= (200,200),
                                          batch_size = 3,
                                          class_mode = 'binary')

# Konvertuojamos visos pažymėtame duomenų rinkinyje esančios klasės į skaitinę vertę
train_dataset.class_indices

# Patikrinimas
train_dataset.classes

##	Neuroninio tinklo modelis
# Modelio kūrimui naudojamas konvoliucinis neuroninis tinklas 
model = tf.keras.models.Sequential([ tf.keras.layers.Conv2D(16, (3,3),activation = 'relu', input_shape =(200,200,3)),
                                   tf.keras.layers.MaxPool2D(2,2), 
                                   #
                                   tf.keras.layers.Conv2D(32, (3,3),activation = 'relu'),
                                   tf.keras.layers.MaxPool2D(2,2), 
                                   #
                                   tf.keras.layers.Conv2D(64, (3,3),activation = 'relu'),
                                   tf.keras.layers.MaxPool2D(2,2),
                                   ##
                                   tf.keras.layers.Flatten(),
                                   ##
                                   tf.keras.layers.Dense(512, activation= 'relu'),
                                   ##
                                   tf.keras.layers.Dense(1, activation='sigmoid' )
                                   ])

# Modelis konfigūruojamas 
model.compile(loss= 'binary_crossentropy',
              optimizer = RMSprop(lr=0.001),
              metrics =['accuracy'])

# Modelis apmokomas
epochs = 15

callbacks = [keras.callbacks.ModelCheckpoint("save_at_{epoch}.h5")]

model.fit (train_dataset,
           epochs=epochs,
           callbacks=callbacks)

## Modelio rezultatai
# Modelis buvo pritaikytas testuojamai (test) duomenų bazei
dir_path = '/content/test'
count_0 = 0
count_1 = 0

for i in os.listdir(dir_path):
    img = image.load_img(os.path.join(dir_path, i))
    img = img.resize((200, 200))  # Resize the image to match the model's input shape
    img.show()

    X = image.img_to_array(img)
    X = np.expand_dims(X,axis =0)
    images = np.vstack([X])

    var = model.predict(images)
    if var == 0:
       print("nera naviko")
    else:
       print("yra navikas")

    prediction = model.predict(images)
    if prediction == 0:
        count_0 += 1
    else:
        count_1 += 1
       

accuracy = count_1  * 100 / 155

print("Modelio tikslumas: {:.2f}%".format(accuracy))
print("MRT nuotraukos, kuriuose nėra naviko:", count_0)
print("MRT nuotraukos, kuriuose matomas navikas:", count_1)

# Grafiko braižymas 
labels = ['Nėra', 'Yra']
counts = [count_0, count_1]

plt.bar(labels, counts)
plt.xlabel('Ar yra navikas')
plt.ylabel('Nuotraukų skaičius')
plt.title('MRT nuotraukų skaičius ar yra matomi navikai')

for i, count in enumerate(counts):
    plt.text(i, count, str(count), ha='center', va='bottom')

plt.show()